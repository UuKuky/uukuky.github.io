<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Markdown语法</title>
      <link href="/posts/61132/"/>
      <url>/posts/61132/</url>
      
        <content type="html"><![CDATA[<p>@<a href="%E8%BF%99%E9%87%8C%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%AE%E5%BD%95%E6%A0%87%E9%A2%98">TOC</a></p><h1 id="欢迎使用Markdown编辑器"><a href="#欢迎使用Markdown编辑器" class="headerlink" title="欢迎使用Markdown编辑器"></a>欢迎使用Markdown编辑器</h1><p>你好！ 这是你第一次使用 <strong>Markdown编辑器</strong> 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。</p><h2 id="新的改变"><a href="#新的改变" class="headerlink" title="新的改变"></a>新的改变</h2><p>我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：</p><ol><li><strong>全新的界面设计</strong> ，将会带来全新的写作体验；</li><li>在创作中心设置你喜爱的代码高亮样式，Markdown <strong>将代码片显示选择的高亮样式</strong> 进行展示；</li><li>增加了 <strong>图片拖拽</strong> 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；</li><li>全新的 <strong>KaTeX数学公式</strong> 语法；</li><li>增加了支持<strong>甘特图的mermaid语法[^1]</strong> 功能；</li><li>增加了 <strong>多屏幕编辑</strong> Markdown文章功能；</li><li>增加了 <strong>焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置</strong> 等功能，功能按钮位于编辑区域与预览区域中间；</li><li>增加了 <strong>检查列表</strong> 功能。<br> [^1]: <a href="https://mermaidjs.github.io/">mermaid语法说明</a></li></ol><h2 id="功能快捷键"><a href="#功能快捷键" class="headerlink" title="功能快捷键"></a>功能快捷键</h2><p>撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd><br>重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd><br>加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd><br>斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd><br>标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd><br>无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd><br>有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd><br>检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><br>插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd><br>插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd><br>插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd><br>查找：<kbd>Ctrl/Command</kbd> + <kbd>F</kbd><br>替换：<kbd>Ctrl/Command</kbd> + <kbd>G</kbd></p><h2 id="合理的创建标题，有助于目录的生成"><a href="#合理的创建标题，有助于目录的生成" class="headerlink" title="合理的创建标题，有助于目录的生成"></a>合理的创建标题，有助于目录的生成</h2><p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br>输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br>以此类推，我们支持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p><h2 id="如何改变文本的样式"><a href="#如何改变文本的样式" class="headerlink" title="如何改变文本的样式"></a>如何改变文本的样式</h2><p><em>强调文本</em> <em>强调文本</em></p><p><strong>加粗文本</strong> <strong>加粗文本</strong></p><p>&#x3D;&#x3D;标记文本&#x3D;&#x3D;</p><p><del>删除文本</del></p><blockquote><p>引用文本</p></blockquote><p>H<del>2</del>O is是液体。</p><p>2^10^ 运算结果是 1024.</p><h2 id="插入链接与图片"><a href="#插入链接与图片" class="headerlink" title="插入链接与图片"></a>插入链接与图片</h2><p>链接: <a href="https://www.csdn.net/">link</a>.</p><p>图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw" alt="Alt"></p><p>带尺寸的图片: ![Alt](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw</a> &#x3D;30x30)</p><p>居中的图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center" alt="Alt"></p><p>居中并且带尺寸的图片: ![Alt](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center</a> &#x3D;30x30)</p><p>当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</p><h2 id="如何插入一段漂亮的代码片"><a href="#如何插入一段漂亮的代码片" class="headerlink" title="如何插入一段漂亮的代码片"></a>如何插入一段漂亮的代码片</h2><p>去<a href="https://mp.csdn.net/console/configBlog">博客设置</a>页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <code>代码片</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An highlighted block</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="生成一个适合你的列表"><a href="#生成一个适合你的列表" class="headerlink" title="生成一个适合你的列表"></a>生成一个适合你的列表</h2><ul><li>项目<ul><li>项目<ul><li>项目</li></ul></li></ul></li></ul><ol><li>项目1</li><li>项目2</li><li>项目3</li></ol><ul><li><input disabled="" type="checkbox"> 计划任务</li><li><input checked="" disabled="" type="checkbox"> 完成任务</li></ul><h2 id="创建一个表格"><a href="#创建一个表格" class="headerlink" title="创建一个表格"></a>创建一个表格</h2><p>一个简单的表格是这么创建的：</p><table><thead><tr><th>项目</th><th>Value</th></tr></thead><tbody><tr><td>电脑</td><td>$1600</td></tr><tr><td>手机</td><td>$12</td></tr><tr><td>导管</td><td>$1</td></tr></tbody></table><h3 id="设定内容居中、居左、居右"><a href="#设定内容居中、居左、居右" class="headerlink" title="设定内容居中、居左、居右"></a>设定内容居中、居左、居右</h3><p>使用<code>:---------:</code>居中<br>使用<code>:----------</code>居左<br>使用<code>----------:</code>居右</p><table><thead><tr><th align="center">第一列</th><th align="right">第二列</th><th align="left">第三列</th></tr></thead><tbody><tr><td align="center">第一列文本居中</td><td align="right">第二列文本居右</td><td align="left">第三列文本居左</td></tr></tbody></table><h3 id="SmartyPants"><a href="#SmartyPants" class="headerlink" title="SmartyPants"></a>SmartyPants</h3><p>SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：</p><table><thead><tr><th>TYPE</th><th>ASCII</th><th>HTML</th></tr></thead><tbody><tr><td>Single backticks</td><td><code>&#39;Isn&#39;t this fun?&#39;</code></td><td>‘Isn’t this fun?’</td></tr><tr><td>Quotes</td><td><code>&quot;Isn&#39;t this fun?&quot;</code></td><td>“Isn’t this fun?”</td></tr><tr><td>Dashes</td><td><code>-- is en-dash, --- is em-dash</code></td><td>– is en-dash, — is em-dash</td></tr></tbody></table><h2 id="创建一个自定义列表"><a href="#创建一个自定义列表" class="headerlink" title="创建一个自定义列表"></a>创建一个自定义列表</h2><dl><dt>Markdown</dt><dd>Text-to-HTML conversion tool</dd></dl><dl><dt>Authors<br>:  John</dt><dd>Luke</dd></dl><h2 id="如何创建一个注脚"><a href="#如何创建一个注脚" class="headerlink" title="如何创建一个注脚"></a>如何创建一个注脚</h2><p>一个具有注脚的文本。<a href="%E6%B3%A8%E8%84%9A%E7%9A%84%E8%A7%A3%E9%87%8A">^2</a></p><h2 id="注释也是必不可少的"><a href="#注释也是必不可少的" class="headerlink" title="注释也是必不可少的"></a>注释也是必不可少的</h2><p>Markdown将文本转换为 HTML。</p><p>*[HTML]:   超文本标记语言</p><h2 id="KaTeX数学公式"><a href="#KaTeX数学公式" class="headerlink" title="KaTeX数学公式"></a>KaTeX数学公式</h2><p>您可以使用渲染LaTeX数学表达式 <a href="https://khan.github.io/KaTeX/">KaTeX</a>:</p><p>Gamma公式展示 $\Gamma(n) &#x3D; (n-1)!\quad\forall<br>n\in\mathbb N$ 是通过欧拉积分</p><p>$$<br>\Gamma(z) &#x3D; \int_0^\infty t^{z-1}e^{-t}dt,.<br>$$</p><blockquote><p>你可以找到更多关于的信息 <strong>LaTeX</strong> 数学表达式<a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">here</a>.</p></blockquote><h2 id="新的甘特图功能，丰富你的文章"><a href="#新的甘特图功能，丰富你的文章" class="headerlink" title="新的甘特图功能，丰富你的文章"></a>新的甘特图功能，丰富你的文章</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title Adding GANTT diagram functionality to mermaid</span><br><span class="line">        section 现有任务</span><br><span class="line">        已完成               :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        进行中               :active,  des2, 2014-01-09, 3d</span><br><span class="line">        计划一               :         des3, after des2, 5d</span><br><span class="line">        计划二               :         des4, after des3, 5d</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>甘特图</strong> 语法，参考 <a href="https://mermaidjs.github.io/">这儿</a>,</li></ul><h2 id="UML-图表"><a href="#UML-图表" class="headerlink" title="UML 图表"></a>UML 图表</h2><p>可以使用UML图表进行渲染。 <a href="https://mermaidjs.github.io/">Mermaid</a>. 例如下面产生的一个序列图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?</span><br><span class="line">李四--&gt;&gt;王五: 你最近怎么样，王五？</span><br><span class="line">李四--x 张三: 我很好，谢谢!</span><br><span class="line">李四-x 王五: 我很好，谢谢!</span><br><span class="line">Note right of 王五: 李四想了很长时间, 文字太长了&lt;br/&gt;不适合放在一行.</span><br><span class="line"></span><br><span class="line">李四--&gt;&gt;张三: 打量着王五...</span><br><span class="line">张三-&gt;&gt;王五: 很好... 王五, 你怎么样?</span><br></pre></td></tr></table></figure><p>这将产生一个流程图。:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[长方形] -- 链接 --&gt; B((圆))</span><br><span class="line">A --&gt; C(圆角长方形)</span><br><span class="line">B --&gt; D&#123;菱形&#125;</span><br><span class="line">C --&gt; D</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>Mermaid</strong> 语法，参考 <a href="https://mermaidjs.github.io/">这儿</a>,</li></ul><h2 id="FLowchart流程图"><a href="#FLowchart流程图" class="headerlink" title="FLowchart流程图"></a>FLowchart流程图</h2><p>我们依旧会支持flowchart的流程图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flowchat</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op=&gt;operation: 我的操作</span><br><span class="line">cond=&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>Flowchart流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/">这儿</a>.</li></ul><h2 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 <strong>文章导出</strong> ，生成一个.md文件或者.html文件进行本地保存。</p><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，<br>继续你的创作。</p>]]></content>
      
      
      <categories>
          
          <category> 工具类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签2 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构--线性表</title>
      <link href="/posts/61132/"/>
      <url>/posts/61132/</url>
      
        <content type="html"><![CDATA[<p>#数据结构–线性表</p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表是一种基础的数据结构，用于表示元素集合，这些元素按照一对一的线性关系排列。在线性表中，除了第一个和最后一个元素，每个元素都只有一个直接前驱和一个直接后继。</p><p>线性表可以分为两类:顺序表(线性表的顺序表示)和链表(线性表的链式表示)</p><h3 id="1-1、线性表的顺序存储表示"><a href="#1-1、线性表的顺序存储表示" class="headerlink" title="1.1、线性表的顺序存储表示"></a>1.1、线性表的顺序存储表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//顺序存储的存储结构</span><br><span class="line">#define MAXSIZE 100  //线性表的可能达到的最大长度</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  ElemType *elem;  //存储空间的基地址</span><br><span class="line">  int length;      //当前长度</span><br><span class="line"> </span><br><span class="line">&#125;Sqlist;           //顺序表的结构体类型为Sqlist</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>typedef关键字用于为已存在的数据类型创建一个新的名字,如上面的代码中为新建的结构体起名为Sqlist。</p><p>Elemtype 是为了描述统一而制定的,实际运用时使用typedef 数据类型 Elemtype为Elemtype确定数据类型。(后面的status也是如此)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef 数据类型 Elemtype //eg.typedef int Elemtype</span><br></pre></td></tr></table></figure><p>顺序存储中结构体也可以作为元素对象，即elem。举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//定义一个结构体，包含学生姓名和学号</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  string name;   //姓名</span><br><span class="line">  string ID;     //学号</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line">//定义顺序表</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Student *elem;</span><br><span class="line">  int length;</span><br><span class="line">&#125;Sqlist;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>说白了就是创建一个名为elem的动态数组,其中elem[i]中存储的都是学生这个结构体，其中length表明顺序表中的元素个数，最后一个元素为elem[length-1].</p><h3 id="1-2、顺序表中的基本操作"><a href="#1-2、顺序表中的基本操作" class="headerlink" title="1.2、顺序表中的基本操作"></a>1.2、顺序表中的基本操作</h3><p>(1)初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">define OK 1</span><br><span class="line">define OVERFLOW -2</span><br><span class="line">Status InitList(Sqlist &amp;amp;L)</span><br><span class="line">&#123;//构造一个空的顺序表</span><br><span class="line">  L.elem=new ElemType[MAXSIZE]; //为顺序表分配一个大小为MAXSIZE的空间</span><br><span class="line">  if(!L.elem)exit(OVERFLOW);  </span><br><span class="line">  L.length=0;</span><br><span class="line">  return OK;</span><br><span class="line">  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这里有个代码小技巧,退出程序使用exit(OVERFLOW)而不直接使用exit(-2),而OVERFLOW也是我们进行预定义的 这是为什么呢.</p><p>虽然两种写法都可以,且都不会影响代码的运行结果,但是使用OVERFLOW就很容易知道是溢出错误。</p><p>此外,这里使用到了<code>new</code>关键字动态分配内存,即在程序运行时（而非编译时）分配的内存，它允许程序在需要时请求更多的内存，并在不再需要时释放内存。</p><p><code>new</code>关键字的使用通常遵循以下步骤：</p><ol><li>分配内存：<code>new</code>会在堆（heap）上为对象分配足够的内存。1. 构造对象：如果分配的是类类型的对象，<code>new</code>会调用该类的构造函数来初始化对象。1. 返回指针：<code>new</code>操作完成后，会返回一个指向分配内存的指针。<br>（2）取值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status GetElem(Sqlist L,int i,Elemtype &amp;amp;e)</span><br><span class="line">&#123;</span><br><span class="line">  if(i&amp;lt;1||i&amp;gt;L.length) return ERROR</span><br><span class="line">  e=L.elem[i-1]</span><br><span class="line">  return OK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(3)查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int LcateElem(Sqlist L,Elemtype e)</span><br><span class="line">&#123;</span><br><span class="line">  for(int i=0;i&amp;lt;L.length;i++)</span><br><span class="line">     if(L.elem[i]==e)</span><br><span class="line">        return i+1;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4)插入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert(Sqlist &amp;amp;L,int i,Elemtype e) //i:插入位置 e:插入的元素</span><br><span class="line">&#123;</span><br><span class="line">  if(L.length==MAXSIZE) return ERROR;</span><br><span class="line">  if(i&amp;lt;1||i&amp;gt;L.length+1) return ERROR;</span><br><span class="line">  for(int j=L.length-1; j&amp;gt;=i-1;j--)</span><br><span class="line">     L.elem[j+1]=L.elem[j];</span><br><span class="line">  L.elem[i-1]=e;</span><br><span class="line">  ++L.length;</span><br><span class="line">  return OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(5)删除(删除第i个元素)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete(Sqlist &amp;amp;L,int i)</span><br><span class="line">&#123;</span><br><span class="line">  if(i&amp;lt;1||i&amp;gt;L.length) return ERROR;</span><br><span class="line">  for(int j=i-1;j&amp;lt;L.length;j++)</span><br><span class="line">     L.elem[j-1]=L.elem[j];</span><br><span class="line">  --L.length;</span><br><span class="line">  return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1、线性表的链式表示"><a href="#2-1、线性表的链式表示" class="headerlink" title="2.1、线性表的链式表示"></a>2.1、线性表的链式表示</h3><p>链表是一种线性数据结构，由一系列节点组成，每个节点包含数据和一个或多个指向其他节点的引用（或指针）。链表的特点是节点在内存中不必连续存储，它们通过指针连接，这样可以更有效地利用内存空间，并且可以快速地进行插入和删除操作。</p><p>线性表的线性表示可以称之为链表，链表又分为单链表、循环链表、双向链表。</p><ol><li><strong>单向链表（Single Linked List）</strong>：每个节点只包含数据和指向下一个节点的指针。最后一个节点的指针指向null，表示链表的末尾。 1.  <strong>双向链表（Double Linked List）</strong>：每个节点除了数据和指向下一个节点的指针外，还有一个指向前一个节点的指针。这使得双向链表可以从两个方向遍历。 1.  <strong>循环链表（Circular Linked List）</strong>：在循环链表中，最后一个节点的指针不是指向null，而是指向第一个节点，形成一个环。这种链表可以无限循环遍历。</li></ol><h4 id="2-1-1-单链表的定义和表示"><a href="#2-1-1-单链表的定义和表示" class="headerlink" title="2.1.1 单链表的定义和表示"></a>2.1.1 单链表的定义和表示</h4><p>在单链表中，每个元素都是一个独立的节点，每个节点由两部分组成：数据域和指针域。数据域用于存储节点的值，指针域（通常称为“下一个指针”或“后继指针”）用于指向下一个节点。</p><img alt="" height="320" src="https://img-blog.csdnimg.cn/direct/b4126646d31a42459286369e6f4831a6.png" width="916"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//单链表的存储结构</span><br><span class="line">typedef struct LNode</span><br><span class="line">&#123;</span><br><span class="line">  Elemtype data;           //结点的数据域</span><br><span class="line">  Struct LNode *next;      //结点的指针域</span><br><span class="line">&#125;LNode,*LinkList;          //LinkList为指向结构体LNode的指针类型</span><br></pre></td></tr></table></figure><p>ps.对于初学者而言,可能有点不理解结构体中定义结构体指针这句代码,原因在于对c语言的编译过程还不是太了解。</p><p>在C语言中，定义一个结构体时，可以在定义内部使用结构体类型名来声明指向该结构体的指针。这是因为结构体类型名在结构体定义的开始就已经可见了。因此，即使在结构体定义完成之前，也可以使用 <code>struct LNode *next;</code> 来声明一个指向 <code>struct LNode</code> 的指针。</p><p>另一方面，<code>LNode</code> 是通过 <code>typedef</code> 关键字定义的 <code>struct LNode</code> 的一个别名。这个别名在 <code>typedef</code> 语句之后才有效。因此，在结构体定义内部，不能使用 <code>LNode *next;</code>，因为此时 <code>LNode</code> 别名还没有被定义。</p><h4 id="2-1-2、单链表中的基本操作"><a href="#2-1-2、单链表中的基本操作" class="headerlink" title="2.1.2、单链表中的基本操作"></a>2.1.2、单链表中的基本操作</h4><p>（1）初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status InitList（LinkList &amp;amp;L）</span><br><span class="line">&#123;</span><br><span class="line">  L=new LNode;</span><br><span class="line">  L-&amp;gt;next=NULL;</span><br><span class="line">  return OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里new出来的L就是图2.8中的L,它只是一个头指针，并没有为其数据域赋值。</p><p>（2）取值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status GetElem(LinkLIst &amp;amp;,int i,Elemtype &amp;amp;e)</span><br><span class="line">&#123;</span><br><span class="line">  LNode *p=L-&amp;gt;next;</span><br><span class="line">  int j=1;</span><br><span class="line">  while(p&amp;amp;&amp;amp;j&amp;lt;i)</span><br><span class="line">  &#123;</span><br><span class="line">    p=p-&amp;gt;next;</span><br><span class="line">    ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  if(!p||j&amp;gt;i)return ERROR;</span><br><span class="line">  e=p-&amp;gt;data;</span><br><span class="line">  return OK;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)查找(按值查找)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LNode* LocateElem(LinkList L,Elemtype e)</span><br><span class="line">&#123;</span><br><span class="line">  LNode *p=L-&amp;gt;next;</span><br><span class="line">  while(p&amp;amp;&amp;amp;p-&amp;gt;data!=e)</span><br><span class="line">  &#123;</span><br><span class="line">    p=p-&amp;gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在函数定义位置可以知道我们返回的是一个指针类型的数据,但是教材上的定义为LNode *Locate()</p><ul><li>在LocateElem的右上角可能让很多小伙伴产生疑问?但其实在c++编译的过程中,<em>默认是属于前面LNode数据返回值类型的,因为函数名左上角带星号没什么意义。所以两种写法都是一样的。但是在定义指针变量的的时候</em>应该紧挨变量名 eg.LNode *p</li></ul><p>（4）插入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert(Sqlist &amp;amp;L,inti,Elemtype e)</span><br><span class="line">&#123;</span><br><span class="line">  LNode *p=L;</span><br><span class="line">  int j=0;</span><br><span class="line">  while(p &amp;amp;&amp;amp; j&amp;lt;i-1)</span><br><span class="line">  &#123;</span><br><span class="line">    p=p-&amp;gt;next;</span><br><span class="line">    ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  if(!p || j&amp;gt;i+1)    //这个地方个人认为j&amp;gt;i+1有点多余,根据上面代码,j不可能大于i+1,欢迎思考评论</span><br><span class="line">    reruen ERROR</span><br><span class="line">  s=new LNode;       //区别LNode *s</span><br><span class="line">  s-&amp;gt;data=e;</span><br><span class="line">  s-&amp;gt;next=p-&amp;gt;next;</span><br><span class="line">  p-&amp;gt;next=s;</span><br><span class="line">  return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> <code>LNode *p</code> 和 <code>p = new LNode</code> 是指针声明的两种不同用法，它们在内存分配和对象构造方面有显著差异。 </p></blockquote><ul><li><code>LNode *p</code>： 这行代码声明了一个指向 <code>LNode</code> 类型对象的指针变量 <code>p</code>。这个声明并没有分配任何实际的内存，也没有构造任何 <code>LNode</code> 对象。它只是告诉编译器 <code>p</code> 是一个可以指向 <code>LNode</code> 类型对象的指针。此时，指针 <code>p</code> 的值是未定义的，如果尝试访问它所指向的内存，将会导致未定义行为，可能引发程序错误或崩溃。 -  <code>p = new LNode</code>： 这行代码不仅声明了一个指针变量 <code>p</code>，还使用了 <code>new</code> 运算符来动态分配内存，并构造了一个 <code>LNode</code> 类型的对象。<code>new LNode</code> 会分配足够大小的内存来存储一个 <code>LNode</code> 对象，并调用 <code>LNode</code> 的构造函数来初始化这块内存。分配的内存的地址被赋值给指针 <code>p</code>，此时 <code>p</code> 指向一个新的 <code>LNode</code> 对象。使用 <code>new</code> 分配的内存储需要使用 <code>delete</code> 来释放，以避免内存泄漏。<br> 简而言之，<code>LNode *p</code> 只是声明了一个指针，而 <code>p = new LNode</code> 声明了一个指针并分配了内存来存储一个 <code>LNode</code> 对象，同时构造了该对象。</li></ul><p> </p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签2 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
